# Привет, лунатики!

### TODO:

- Добить игру:
   	- картинка на начало и конец игры, обработать сообщение о конце игры - Макс
   	- писать игровые логи (начало-конец игры, результат итд) в базу данных - Наташа
   	- добавить счетчик времени, на сервере и на клиенте, сделать лимит раунда по времени - ?
- Переехать на контейнеры и подключить проверки на SQL иньекции и другие атаки - Константин
- Доделать игрока-бота - Анна
- Сделать менеджер фокуса элементов, чтобы не двигались ракетки, когда печатаешь в чате и не двигался сайт, когда в игре нажимаешь кнопки, это можно вынести в отдельный entrypoint - Слава
- Почистить проект, убрать лишнее, распихать повторяющиеся части на функции - ?
- Обработка ошибок (нужно будет разделить на части) - ?
- Реализовать турнир по плану (нужно будет разбить на части) - ?
- Продумать и сделать приглашение в игру - ?
  
### Tournament plan:

Только один турнир на сервер! На сервере должен быть флаг tournamentIsActive = true/false или просто должна быть сущность (класс) tournament, которая либо есть, либо она null/undefined/whatever. 

#### Турнир будет состоять из 2 этапов (есстественно список может пополняться и поправляться)
* 1) Этап создания:
	* При нажатии на кнопку создания турнира приходит оповещение в чат о том что есть возможность создать турнир и запрос на выбор сколько игроков будет в турнире
   	* Кнопка начала турнира должна выключать остальные кнопки начала игры, а то бардак будет, не сдюжим
	* Пользователь может выбрать несколько вариантов количества игроков, например сделать выбор через всплывающее окно (https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/dialog#handling_the_return_value_from_the_dialog)
	* После выбора клиент посылает POST запрос и на сервере создается обьект Tournament и/или переключается tournamentIsActive, начинается ожидание игроков и каждому пользователю в чате приходит оповещение о том что турнир создан и в чате же присутствует кнопочка присоединиться. 
	* Должна быть возможность присоединиться к турниру если пользователь зашел на сайт после его создания - при открытии страницы должна выполниться проверка, нет ли на сервере незаполненного турнира и первое сообщение в чате (ну или второе) должно быть, что есть набор на турнир с кнопкой присоединиться
	* Система может ждать заполнения игроков либо сбрасывать этап создания если прошло условных 5-10 минут, с оповещением в чат и очисткой сущности на сервере
* 2) Этап игры
	* После того как заполнились места приходит анонс о том что турнир начался и оповещение каждому игроку о том с кем он будет соревноваться через 10-30 секунд ( не сразу же начинать махач )
	* Противники могут выбираться случайно либо по порядку добавления, либо, если будет рейтинг игрока - по рейтингу
	* Игра будет идти либо по времени ( минута например ) либо до того как наберется определенное количество очков ( 20 к примеру ) либо вообще и то и то хехе 
	* В чат будет приходить о каждом завершенном матче и его результате и к нему будет следовать оповещение о том с кем победитель будет соревноваться следующим
	* После последней победы будет супер крутое оповещение (в чат?) о победе в турнире победителю и можно вывести ему в чат его любое достижение ( например забил 20 без единого пропуска шарика и тд)
   
* П С
	* В ветке славы есть примерный темплейт того как могут выглядеть кнопки ( кнопка присоединения есть в кнопке профиля в чате )

### Как запустить

* Скачать репозиторий =)
* добавить в корень проекта .env файл, за содержимым - к Максу
* для двухфакторной авторизации нужно установить на телефон Google Authentificator ( https://apps.apple.com/us/app/google-authenticator/id388497605	/	https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2 ), этим приложением отсканировать qr код ./data/OTP/QR.png, он позволит проходить авторизацию с логином-паролем админа.
* `npm i`
* `npm run build`
* `npm start`

### Typescript

Тайпскрипт это надстройка над жаваскриптом, которая позволяет определять и контроллировать типы всего - от примитивных типов данных до классов и обьектов.

Есть стандартный компилятор (tsc), который просто стирает из текста все типы и получается, собственно, обычный жаваскрипт.

Есть инструменты типа ts-node, которые пережевывают тайпскрипт файлы на ходу, в рантайме, без создания .js файлов.

В любом случае тайпскрипт требует конфиг-файл - tsconfig.json, он лежит в корне проекта.
Там относителььно несложные параметры и есть комментарии из стандартного шаблона, можно поковырять.

Четыре важные настройки там это: target, module, moduleResolution и allowSyntheticDefaultImports.
Они определяют, какие правила импортов и экспортов и какие стандарты будут применяться при компиляции.
С ними черт ногу сломит, но вот так, как сейчас - работает =)

С импортами и экспортами - они как бы похожи на инклюды из С/С++ но, на самом деле, немного другая история, надо привыкнуть.

#### Важно понимать:
Все проверки типов существуют только пока файл - .ts

После компиляции в .js вся типизация исчезает, а жаваскрипт позовляет менять тип переменной на ходу и принимать, например, в качестве аргумента обьект любого типа,
лишь бы был объект.

Так что если кому-то захочется поиграть в сурьёзную рантайм валидацию - нужно прямо писать функцию, где проверяется наличие в объекте всех нужных полей, тут вам не С/С++.

### Webpack

Вебпак - это бандлер, инструмент, который, грубо говоря, запихивает твой большой проект в один файл. Это его базовая функция, но далеко не единственная.

Там тоже черт ногу сломит с настройками, сейчас используется два конфига - webpack.back.ts и webpack.front.ts, которые собирают каждый свою часть.
Они вызываются базовым конфигом, webpack.config.js, я не смог запихать его в тайпскрипт без неприятных танцев с бубнами.

Кроме компиляции .ts файлов он обрабатывает ассеты (картинки, например),
файлы со стилями (.css), динамически генерит финальный html файл для фронтенда и всякое такое.

Использовать бандлеры можно, я сверялся с несколькими темами в слаке, народ даже писал официальный запрос в Париж.
Чуть ниже опишу пару ситуаций, где может понадобиться редактировать конфиг.

### Fastify

Это, по сути, набор инструментов, которые позволяют быстро написать быстрый сервер =)

В этом проекте он нужен, чтобы не писать сервер на РНР, а чтобы вся наша тут история могла быть написана на одном языке и использовать без проблем общий код, общие константы итд.

Он бысрее своих конкурентов (например Express.js), по крайней мере на тестах, но не очень популярен. ХЗ почему.

Часть его скорости, как я понял - в его модульности. Ты подключаешь только те плагины, которые тебе нужны и все, что не нужно, соответственно - не жрет ресурсы.

Он сервит все файлы клиенту, обрабатывает вебсокеты для чата и игры, можно попробовать обращения к базе данных тоже сделать через него.
Там даже можно относительно легко настроить проксирование - но это скорее пригодится, когда/если будем распиливать проект на микросервисы.

### Babylon.js

Это библиотека для создания и отображения 3д-сцен. Сейчас она используется так - есть базовая сцена, где только описаны обьекты и их положение на сцене.

Потом от нее наследуются сцены отдельно для фронта и для бека. Можно поковырять src/scenes, там довольно понятно.
Сцена для фронта включает освещение, тени, (потом добавлю) текстуры, итд.
Сцена для бека сейчас бежит на так называемом NullEngine, он не занимается генерацией визуальной части, только высчитывает обьекты, коллизии физику итд.

Руководствуясь исключительно благими намерениями, я отнаследовал от класса NullEngine свой класс и постепенно, сам того не заметив, сделал из него god-object.
Там хранится всё - сцены, игроки, их состояния, всё.
Пока вроде удобно, но если партия скажет - я разделю на логические части или хотя бы не буду посылать в функции весь обьект, посмотрим.                                                                                       
Я думал, что камеру будет достаточно подключить только для фронт-сцены, но там так устроено, что без камеры (даже если она ничего и не показывает) движок не может считать сам тики (кадры, если угодно), так что камера ушла из фронтенда в базовую сцену.

Вообще библиотека очень мощная и можно в ней зафигачить очень серьезные вещи, но мне бы понимать, в какую сторону копать - неплохо бы иметь визуалььный референс, как для самой игры, так и для всего сайта целиком.

### Сборка

Для сборки и запуска используем пакетный менеджер, встроенный в экосистему Node.js - npm (node packe manager).
Node.js конфигурирует себя под текущий проект согласно файлу package.json, он лежит в корне проекта. Сейчас он супер-простой, но туда можно тоже напихать всякого.
Сначала устанавливаем зависимости (внешние библиотеки и инструменты, которые нужны для сборки проекта и последующего использования):

`npm install`
или
`npm i`.

Зависимости, указанные в файле скачаются и распакуются в папку node_modules.

Есть два вида зависимостей - devDependencies, которые нужны только в момент разработки и сборки;
и просто dependencies, которые нужны так или иначе в рантайме (то бишь во время исполнения программы).

Их можно установить отдельно:

`npm i -D` и `npm i --omit=dev`

Это пригодится для создания отдельных слоев в докере.
Можно еще поставить зависимости глобально - это значит, что они будут доступны во всей системе, не только в папке проекта, но нам это нафиг не надо, да и прямо на школьную машину глобально ничего не поставить -  нужен root.

Список установленных зависимостей можно вывести с помощью
`npm list`
или
`npm list global` если хочется посмотреть, что там установлено для всей системы.

Потом собираем проект:
`npm run build`
или
`npm run build:prod`.

Эти команды можно посмотреть, изменить или добавить свои в файле package.json. Обе вызывают вебпак в режиме разработки или продакшена соответсвенно.
Пока достаточно просто build.

И запускаем сервер:
`npm start`.

Пока все крутится на порту 12800, по-хорошему надо сделать .env файл, который не будет в репозитории или будет в докер-секретах или что-то такое, и считывать порт оттуда.

### Как добавить отдельный скрипт в html файл

Создаем .ts файл в ./src/front. Файл может использовать код из других файлов и вообще использовать все, что угодно, но он должен быть отдельной "точкой входа", то есть тем, с чего начинается вся логика конкретно этого элемента. В данный момент у нас точки входа четыре - языки, логин, игра и чат. Каждая отвечает за свой блок на странице и в данный момент не лезет в логику другой. Это, конечно, всегда можно исправить =)

Идем в файл ./webpack.front.ts, там находим часть с точками входа:\
`entry: {`\
	`"i18next": path.resolve(appDir, srcDir, frontDir, "i18next.ts"),`\
	`"login": path.resolve(appDir, srcDir, frontDir, "login.ts"),`\
	`"game": path.resolve(appDir, srcDir, frontDir, "game.ts"),`\
	`"chat": path.resolve(appDir, srcDir, frontDir, "chat.ts")`\
`},`

Добавляем туда по шаблону свой файл.

ГОТОВО, ВЫ ВЕЛИКОЛЕПНЫ! Файлик будет динамически добавлен в скрипты итогового html файла.

Вот  =)


Хотел написать больше, но допишу потом.
Держитесь, прорвёмся.
Макс

