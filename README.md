# Привет, лунатики!

### TODO:

- Все ID вместо GUID, который по сути string, перевести на голые цифры (number), которые получаем от базы данных - Константин делает API над БД, Макс меняет GUID на number
- Сделать передачу ID и имени пользователя в игру и чат на сайте по CustomEvent, посылать на сервер (и в игру, и в чат) оба поля (игра сейчас посылает только ID) -  Макс
- BackScene: Проверить смену state во всех сценах. Посылать сообщение по смене state - Анна
- BackScene: в конце игры посылать по игровому сокету ник победителя
- Доделать игрока-бота - Анна
- Почистить проект, убрать лишнее, распихать повторяющиеся части на функции - ?
- Обработка ошибок (нужно будет разделить на части) - ?
- Продумать и сделать приглашение в игру - ?

### Tournament plan:

Можно создавать несколько турниров.
Пользователь заходит на сайт и может либо создать турнир, либо присоединиться к имеющимся по соответссвующим кнопкам. 
То есть к турниру можно присоединиться только пока не набралось достаточное количество человек. В таблице с турниром должно быть либбо поле state типа "не заполнился", "заполнился/бежит", закончился.


#### База данных:

Все игры пишутся в таблицу со следующими полями:

	Game ID | State | User1 ID | User1 score | User2 ID | User2 score

Запись создается при создании игры и поля заполняются или модифицируются в процессе:
	- Game ID, number, пишется при создании игры и никогда не меняется
	- State, "init", "run", "over" (есть тип GameState в ./src/defines/types.ts) изначально "init", потом меняется на "run" и "over". После окончания состояние не меняется.
	- User1/2 ID добавляются по мере добавления игроков, после записи не меняются.
	- Score обновляются после каждого гола

Также есть таблица:

	Tournament ID | Game ID | Round | Players in round

База должна предоставить наружу следующие функции (имена могут быть другие, но суть сохранить, все false можно заменить на throw):

- createGameId() : number
	- найти самый большой ID в первой таблице, новый будет + 1, создать запись с новым ID, State = "init", все остальное по нулям и вернуть ID
- createTournamentId() : number
	- если на сервере уже есть активный турнир, то вернуть -1
	- найти самый большой ID во второй таблице, вернуть его + 1
- addGameToTournamentInDb(tournamentId: number, gameId: number, round: number, playersInRound: number) : bool
	- если во второй таблице есть такая комбинация турнир-игра, то вернуть false
	- создать запись во второй таблице, вернуть true
- updateScoreInDb(gameId: number, userLeftId: number, userRightId: number, scoreLeft: number, scoreRight: number) : bool
	- если нет такой игры, если в игре другие userID, если State === "over", то вернуть false
	- если все норм - обновить запись и вернуть true
- updateStateInDb(gameId: number, state: GameState) : bool
	- если нет такой игры или state === "over", то вернуть fale
	- если норм - обновить запись, вернуть true
- addPlayerToGameInDB(playerId: number, gameId: number) : bool
	- если нет такой игры, то вернуть false
	- если такой игрок есть в игре, то вернуть true
	- если есть уже два игрока, то вернуть false
	- если есть свободный "слот", то обновить запись (добавить игрока в слот) и вернуть true
- getCurrentRoundAndPlayers(tournamentId: number) : [number, number]
	- если во второй таблице нет турнира с таким ID, то вернуть [ -1, -1 ]
	- найти самое большое число в колонке Round и вернуть пару [round, playersInRound] (в последнем раунде количество игроков будет 2, в худшем случе 1)
- getWinner(gameId: number) : number
	- если в первой таблице нет такой игры или State !== "over", вернуть -1
	- вернуть ID игрока с бóльшим счетом
 - getNickById(userId: number) : string

Таким образом не будет никаких NULL-ов в таблице, а все статистики турнира можно вытащить из этих двух таблиц.

#### Игра:

- Сделать в игровой части несколько состояний, можно взять из состояний базовой сцены - init, run, over и какой-то standby, когда все кнопки активны и ждут нажатия. Все смены состояния производить только по сообщению от сервера.
- Обязательно сделать изменения состояния по началу и окончанию игры, по отключению всех игроков.
- Каждая кнопка с началом игры/турнира должна блокировать все кнопки, пока сервер не пришлет ответ.
- ¿ Если сервер не прислал подтверждение о начале игры/турнира в течении минуты - отблокировать обратно ?
- Когда сервер прислал успешное начало игры или турнира - прятать все кнопки.
- При успешном начале простой игры - активировать кнопки обратно только по сообщению о конце игры.
- При успешном начале турнира - активировать кнопки обратно по сообщению о конце турнира. Сообщение может быть послано и в середине турнира, и при нормальном конце, для клиента это не важно, он просто включает нормальное состояние со всеми активнымми кнопками.
- Кнопка "Create a tournamment" посылает запрос на сервер и, в зависимости от того, есть ли активный турнир, сервер посылает соответствующий response. Если есть турнир, то выводить сообщение "There is an active tournament on the server, you may join it in the chat".

Должны быть функции:
- deactivateGameButtons()
- activateGameButtons()
- hideGameButtons(activeButton)
	- прятать все, кроме активной
- showGameButons()
- showWaitUi()
	- показать в игре сообщение типа "Please wait..."
- hideWaitUi()
- showWinUi(winnerNick: string)
	-  показать в игре сообщение `${winnerNick} won!`
- hideWinUi()

соответсвенно, все это должно триггериться только по сообщениям от сервера

#### Чат:
Сделать два вида коммуникации турнира на сервере с чатом в браузере:
1) под чатом, чтобы не скроллить, будет блок с информацией:

- TOURNAMENT
- Players: 8 / 8
- Current round: 1

Соответственно нужно подобное сообщение:
```
type TournamentActive = {
	type = "tournamentAcitve",
	playersCurrent: number,
	playersMax: number,
	roundCurrent = number
}
```

оно будет включать окошко с информацией о турнире под чатом и менять информацию в нем. Также нужно сообщение TournamentInaсtive - оно будет этот блок выключать.

2) А в сам чат, в ту часть, которую скроллишь - будут приходить уведомления по ходу. Варианты уведомлений:
- Открытие турнира:
	- Петя Васечкин начал новый турнир!
	- Желаете присоединиться?
	- <кнопка "конечно хочу!">
		- кнопка должна блокировать (не прятать!!!) все остальные игровые кнопки пока сервер не ответит
		- если сервер не ответил в течение минуты - вывести ошибку во всплывающем окне и разблокировать кнопки
		- если сервер прислал "не могу тебя присоединить" - вывести ошибку во всплывающем окне и разблокировать кнопки
		- если сервер прислал "добавил тебя" -  спрятать все игровые кнопки и оставить только кнопку Tournament, все игровые кнопки будут неактивны до конца турнира
- Кто-то добавился:
	- Вася Пупкин присоединился к турниру!
	- Хотите ли вы тоже?
	- <кнопка "конечно хочу!">
- Турнир заполнился:
	- Настя Здрастьева присоединилась к турниру!
	- Пожелаем удачи участникам!
- Начало каждого круга (round):
	- Начинается круг номер Х!
	- Пары этого круга:
	- A vs B
	- C vs D
	- ...
	- Q - bye ( https://en.wikipedia.org/wiki/Bye_(sports) )
- Завершился чей-то матч:
	- Семён за Миллион выиграл матч!
	- Финальный счет: 11 - 2
- Завершился весь турнир:
	- Поздравляем Оксану из Тосканы с победой в турнире!

(придется всю эту хероту переводить на все языки)

То есть, когда человек заходит на сайт, то при первом соединении чат-сокета сервер посылает на клиент либо Tournament active и "Петя начал турнир", либо TournamentInactive. Потом уже все остальное по ходу развития событий.

#### Сервер:

- Должна быть сущность типа tournament: Tournament | null, которую проверяет чат при заходе пользователя на страницу

#### Class Tournament:

Создается на определенное количество игроков (2, 4, 8, 16). Соответственно нужен Array или Map, чтобы их хранить.

!!! Нужно проверить, что активный пользователь на сервере - это одна сущность и у нас нет отдельного юзера для чата и для игры, как в клиенте, чтобы можно было работать с игровым сокетом и сокетом чата, обращаясь только к одной сущности. Если сущности разные - надо исправить.!!!

Создатель турнира сразу добавляется в список участников, в чат посылается сообщение о новом турнире.
Каждого игрока перед добавлением в каждый следующий раунд пинговать, проверять что оба сокета живы. Кто отрубился - удаляется.
Турнир ждет подключения нужного количества игроков или умирает после 5 минут.

Допустим игроков 8.

По нажатию кнопки "Хочу тоже в турнир" клиент посылает запрос, если турнира вообще нет или нет мест - отправить TournamentJoinFail, если норм - послать TournamentJoinSuccess.

Пока не подключились все игроки:
	- игра: посылается сообщение, включающее режим ожидания ("Please wait", )
	- чат: посылается TournamentActive и все сопутствующие сообщения

Каждая игра проходит как обычная удаленная игра, посылается только после окончания каждой игры сервер должен посылать на сокет игры переход в режим ожидания ("please wait" и неактивные кнопки).

Когда подключились все 8 игроков:
- В начале каждого раунда (до того, как добавили в него сцены и игроков):
	- function initRound(tournamentId: number):
		- Вызываем getCurrentRoundAndPlayers():
			- если пришло [-1,-1], то это первый раунд, нужно обработать всех 8 игроков
			- если пришло [1, 8] / [2, 4] ... (первое это номер раунда, второе это количество игроков):
				- Собираем ID игр этого раунда.
				- если не все игры этого раунда в состоянии "over", то вернуть код ошибки
				- собрать ID победителей этих игр.
		- Пингуем игроков по собранным ID.
		- Кто пингуется, тот проходит в новый раунд, кто не пингуется - не проходит
		- Кто прошел, те по двое добавляются в новые игры.
		- Кто остался без пары - получает bye и игра висит в режиме "Wait".

- Когда одна игра закончилась:
	- вызываем getCurrentRoundAndPlayers().
	- Если игроков <= 2:
		- это был финальный раунд
		- послать всем в сокет чата сообщение о победителе и tournamentInactive
		- послать всем в сокет игры сообщение о переходе в обычный режим (все кнопки активны, в окне игры простое приветствие)
		- сделать tournament = null
		- конец.
	- В остальных случаях послать всем игрокам в чате результат этого матча, перевести оба клиента в режим wait
	- Если во второй таблице базы данных все игры этого раунда имеют State === "over", то завершаем этот раунд.


### Как запустить

* Скачать репозиторий =)
* добавить в корень проекта .env файл, за содержимым - к Максу
* для двухфакторной авторизации нужно установить на телефон Google Authentificator ( https://apps.apple.com/us/app/google-authenticator/id388497605	/	https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2 ), этим приложением отсканировать qr код ./data/OTP/QR.png, он позволит проходить авторизацию с логином-паролем админа.
* `npm i`
* `npm run build`
* `npm start`

### Typescript

Тайпскрипт это надстройка над жаваскриптом, которая позволяет определять и контроллировать типы всего - от примитивных типов данных до классов и обьектов.

Есть стандартный компилятор (tsc), который просто стирает из текста все типы и получается, собственно, обычный жаваскрипт.

Есть инструменты типа ts-node, которые пережевывают тайпскрипт файлы на ходу, в рантайме, без создания .js файлов.

В любом случае тайпскрипт требует конфиг-файл - tsconfig.json, он лежит в корне проекта.
Там относителььно несложные параметры и есть комментарии из стандартного шаблона, можно поковырять.

Четыре важные настройки там это: target, module, moduleResolution и allowSyntheticDefaultImports.
Они определяют, какие правила импортов и экспортов и какие стандарты будут применяться при компиляции.
С ними черт ногу сломит, но вот так, как сейчас - работает =)

С импортами и экспортами - они как бы похожи на инклюды из С/С++ но, на самом деле, немного другая история, надо привыкнуть.

#### Важно понимать:
Все проверки типов существуют только пока файл - .ts

После компиляции в .js вся типизация исчезает, а жаваскрипт позовляет менять тип переменной на ходу и принимать, например, в качестве аргумента обьект любого типа,
лишь бы был объект.

Так что если кому-то захочется поиграть в сурьёзную рантайм валидацию - нужно прямо писать функцию, где проверяется наличие в объекте всех нужных полей, тут вам не С/С++.

### Webpack

Вебпак - это бандлер, инструмент, который, грубо говоря, запихивает твой большой проект в один файл. Это его базовая функция, но далеко не единственная.

Там тоже черт ногу сломит с настройками, сейчас используется два конфига - webpack.back.ts и webpack.front.ts, которые собирают каждый свою часть.
Они вызываются базовым конфигом, webpack.config.js, я не смог запихать его в тайпскрипт без неприятных танцев с бубнами.

Кроме компиляции .ts файлов он обрабатывает ассеты (картинки, например),
файлы со стилями (.css), динамически генерит финальный html файл для фронтенда и всякое такое.

Использовать бандлеры можно, я сверялся с несколькими темами в слаке, народ даже писал официальный запрос в Париж.
Чуть ниже опишу пару ситуаций, где может понадобиться редактировать конфиг.

### Fastify

Это, по сути, набор инструментов, которые позволяют быстро написать быстрый сервер =)

В этом проекте он нужен, чтобы не писать сервер на РНР, а чтобы вся наша тут история могла быть написана на одном языке и использовать без проблем общий код, общие константы итд.

Он бысрее своих конкурентов (например Express.js), по крайней мере на тестах, но не очень популярен. ХЗ почему.

Часть его скорости, как я понял - в его модульности. Ты подключаешь только те плагины, которые тебе нужны и все, что не нужно, соответственно - не жрет ресурсы.

Он сервит все файлы клиенту, обрабатывает вебсокеты для чата и игры, можно попробовать обращения к базе данных тоже сделать через него.
Там даже можно относительно легко настроить проксирование - но это скорее пригодится, когда/если будем распиливать проект на микросервисы.

### Babylon.js

Это библиотека для создания и отображения 3д-сцен. Сейчас она используется так - есть базовая сцена, где только описаны обьекты и их положение на сцене.

Потом от нее наследуются сцены отдельно для фронта и для бека. Можно поковырять src/scenes, там довольно понятно.
Сцена для фронта включает освещение, тени, (потом добавлю) текстуры, итд.
Сцена для бека сейчас бежит на так называемом NullEngine, он не занимается генерацией визуальной части, только высчитывает обьекты, коллизии физику итд.

Руководствуясь исключительно благими намерениями, я отнаследовал от класса NullEngine свой класс и постепенно, сам того не заметив, сделал из него god-object.
Там хранится всё - сцены, игроки, их состояния, всё.
Пока вроде удобно, но если партия скажет - я разделю на логические части или хотя бы не буду посылать в функции весь обьект, посмотрим.
Я думал, что камеру будет достаточно подключить только для фронт-сцены, но там так устроено, что без камеры (даже если она ничего и не показывает) движок не может считать сам тики (кадры, если угодно), так что камера ушла из фронтенда в базовую сцену.

Вообще библиотека очень мощная и можно в ней зафигачить очень серьезные вещи, но мне бы понимать, в какую сторону копать - неплохо бы иметь визуалььный референс, как для самой игры, так и для всего сайта целиком.

### Сборка

Для сборки и запуска используем пакетный менеджер, встроенный в экосистему Node.js - npm (node packe manager).
Node.js конфигурирует себя под текущий проект согласно файлу package.json, он лежит в корне проекта. Сейчас он супер-простой, но туда можно тоже напихать всякого.
Сначала устанавливаем зависимости (внешние библиотеки и инструменты, которые нужны для сборки проекта и последующего использования):

`npm install`
или
`npm i`.

Зависимости, указанные в файле скачаются и распакуются в папку node_modules.

Есть два вида зависимостей - devDependencies, которые нужны только в момент разработки и сборки;
и просто dependencies, которые нужны так или иначе в рантайме (то бишь во время исполнения программы).

Их можно установить отдельно:

`npm i -D` и `npm i --omit=dev`

Это пригодится для создания отдельных слоев в докере.
Можно еще поставить зависимости глобально - это значит, что они будут доступны во всей системе, не только в папке проекта, но нам это нафиг не надо, да и прямо на школьную машину глобально ничего не поставить -  нужен root.

Список установленных зависимостей можно вывести с помощью
`npm list`
или
`npm list global` если хочется посмотреть, что там установлено для всей системы.

Потом собираем проект:
`npm run build`
или
`npm run build:prod`.

Эти команды можно посмотреть, изменить или добавить свои в файле package.json. Обе вызывают вебпак в режиме разработки или продакшена соответсвенно.
Пока достаточно просто build.

И запускаем сервер:
`npm start`.

Пока все крутится на порту 12800, по-хорошему надо сделать .env файл, который не будет в репозитории или будет в докер-секретах или что-то такое, и считывать порт оттуда.

### Как добавить отдельный скрипт в html файл

Создаем .ts файл в ./src/front. Файл может использовать код из других файлов и вообще использовать все, что угодно, но он должен быть отдельной "точкой входа", то есть тем, с чего начинается вся логика конкретно этого элемента. В данный момент у нас точки входа четыре - языки, логин, игра и чат. Каждая отвечает за свой блок на странице и в данный момент не лезет в логику другой. Это, конечно, всегда можно исправить =)

Идем в файл ./webpack.front.ts, там находим часть с точками входа:\
`entry: {`\
	`"i18next": path.resolve(appDir, srcDir, frontDir, "i18next.ts"),`\
	`"login": path.resolve(appDir, srcDir, frontDir, "login.ts"),`\
	`"game": path.resolve(appDir, srcDir, frontDir, "game.ts"),`\
	`"chat": path.resolve(appDir, srcDir, frontDir, "chat.ts")`\
`},`

Добавляем туда по шаблону свой файл.

ГОТОВО, ВЫ ВЕЛИКОЛЕПНЫ! Файлик будет динамически добавлен в скрипты итогового html файла.

Вот  =)


Хотел написать больше, но допишу потом.
Держитесь, прорвёмся.
Макс

